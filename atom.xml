<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>doubleyue的个人博客</title>
  
  
  <link href="https://doubleyue.life/atom.xml" rel="self"/>
  
  <link href="https://doubleyue.life/"/>
  <updated>2022-05-14T10:03:36.855Z</updated>
  <id>https://doubleyue.life/</id>
  
  <author>
    <name>doubleyue</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字节面试的问题准备</title>
    <link href="https://doubleyue.life/2022/05/14/%E5%AD%97%E8%8A%82%E4%B8%89%E9%9D%A2%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87/"/>
    <id>https://doubleyue.life/2022/05/14/%E5%AD%97%E8%8A%82%E4%B8%89%E9%9D%A2%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87/</id>
    <published>2022-05-14T06:52:53.000Z</published>
    <updated>2022-05-14T10:03:36.855Z</updated>
    
    <content type="html"><![CDATA[<p>大早上睡不着的时候翻<a href="https://www.nowcoder.com/">牛客</a>搜字节三面，总结出来的各种问题。</p><p><strong>这篇博客没有答案、只有问题</strong></p><p>答案我估计还得查几天，再慢慢总结吧~</p><h2 id="壹c数据结构相关">壹、C++、数据结构相关</h2><ol type="1"><li>归并排序的思路，时间复杂度，空间复杂度，是否是稳定的排序算法？</li><li>讲一下hashmap<ol type="1"><li>原理</li><li>怎么扩容的，为什么8转换为树，为什么负载因子是0.75</li><li>新建的hashmap初始默认大小是多少</li><li>为什么尾插法能解决死循环</li><li>并发安全的hashmap有那些</li></ol></li><li>arraylist和linkedlist的区别</li><li>hashSet和treeSet区别</li><li>写一个单例</li><li>为什么用volatile，为什么要用synchronized，重排序发生在哪一步</li><li>synchronize的原理？lock和synchronized的区别</li><li>C++中auto关键字实现原理</li><li>说说链接器在链接过程都做了什么</li><li>说说对模板元编程的理解</li><li>常见算法的时间复杂度</li><li>同或、异或</li><li>多态你怎么理解的、写个多态吧</li><li>设计模式<ol type="1"><li>单例</li><li>工厂</li><li>建造者模式</li><li>代理模式</li></ol></li><li>c语言实现memcpy</li><li>停车场，两个出口两个入口，要求有查询剩余车位，以及车辆停车计费的功能，用面向对象的思想怎么设计类</li><li>智能指针</li><li>C++怎么管理内存</li><li>C++怎么管理线程池<ol type="1"><li>多线程的好处？怎么管理多线程中线程数量</li></ol></li><li>C++socket网络编程了解吗</li><li>CPP如何实现垃圾回收</li><li>递归的处理过程</li><li>常用算法对比<ol type="1"><li>DP</li><li>回溯</li><li>贪心</li><li>分支限界</li></ol></li><li>数组和链表的区别</li></ol><h2 id="贰操作系统">贰、操作系统</h2><ol type="1"><li>编译原理</li><li>Linux io模式有哪些</li><li>各种MQ以及EventBus之间的区别，为什么选择了RocketMQ</li><li>为什么用MQ，哪些项目用了MQ的特性</li><li>如何增大消费者消费能力，能否无限增大消费者数量，假如资源无限大可以上线无限个消费者能否无限增大数量</li><li>IO多路复用有哪几种实现？分别介绍优缺点</li><li>内核态和用户态、用户态---&gt;内核态的方式</li><li>对僵尸进程的理解</li><li>线程同步说一下</li><li>线程死锁</li><li>后端开发比较关注的数据库、消息队列、缓存，了解过哪个</li><li>进程、线程、协程<ol type="1"><li>进程和线程的区别</li><li>进程通信的方式</li><li>进程线程的场景题</li><li>说一下协程</li><li>进程切换保存了哪些资源</li><li>为什么进程切换要陷入内核</li></ol></li><li>虚拟内存逻辑地址转物理地址</li><li>生产者消费者模式知道吗？写一个生产者消费者模式吧</li><li>linux中进程怎么通信</li><li>MQ了解吗</li><li>强引用弱引用软引用虚引用对比</li></ol><h2 id="叁计算机网络">叁、计算机网络</h2><ol type="1"><li>url输入后发生什么</li><li><a href="www.baidu.com">百度</a>请求的是什么类型的服务器</li><li>XSS攻击介绍一下，前缀树是用来干啥的</li><li>ipv4和ipv6的区别</li><li>什么是滑动窗口？是否固定？什么时候改变？</li><li>TCP<ol type="1"><li>三次握手四次挥手过程</li><li>为啥握手是三次，挥手是四次？</li><li>为什么要有最后一次挥手？</li><li>非技术角度谈谈三次握手到底在做什么</li></ol></li><li>UDP是什么、UDP如何保证可靠传输（quic）</li><li>http与tcp的keep alive的区别</li><li>http<ol type="1"><li>状态码：501、502、206</li><li>http是什么、header 格式是什么样的？</li><li>https和http的区别。</li><li>get和post的区别</li></ol></li><li>说下 RPC，与 HTTP 的区别</li><li>怎么发起一个网络请求？用C++写一个发起网络请求</li><li>手写个socket的过程</li><li>es的可靠性怎么保证的</li><li>服务器一天收到多个客户端请求，给你这些请求的时间戳和客户端ip ，求一天访问不同客户端最多的分钟</li><li>ping 的过程</li><li>dns</li></ol><h2 id="肆数据库">肆、数据库</h2><ol type="1"><li>mysql连接池</li><li>MySQL为什么要设计索引、索引优化</li><li>慢SQL查询、慢SQL优化</li><li>讲讲分库分表</li><li>索引树高度一般是怎样的，如何根据一次IO的数据量及一些其他数据算出高度</li><li>MySQL联合索引列出各种情况看能否走索引</li><li>插入和删除时索引树的变化</li><li>讲讲分布式锁，如何实现</li><li>SQL和NoSQL的区别，各自在什么场景下使用</li><li>Mysql有哪几种引擎？为什么MyIsam比InnoDb查询快？</li><li>倒排索引是什么？</li><li>说说一条sql语句的执行过程</li><li>缓存和 DB 之间怎么保证数据一致性</li><li>说下索引二八原理、提升读性能牺牲写性能的数据结构一个索引对应一颗 B+树哈希、有序数组、二叉树查询的优缺点那为什么不用跳表呢？</li><li>火车票区间查询怎么设计数据结构比如上海去武汉，途经南京、合肥现在要快速查询出两点之间票的库存</li><li>怎么删除某一行某一列的数据</li><li>innodb的回滚怎么做的，详细一点</li><li>写sql，给一个表，有id 和 name，找出name重复的id</li><li>事务<ol type="1"><li>脏读、幻读</li><li>隔离级别</li></ol></li><li>乐观锁、悲观锁、MVCC</li><li>redis</li><li>select * from xxx where a=‘a’ and b=1 怎么建索引</li><li>如果表中b只有1和2怎么建</li></ol><h2 id="伍算法和其他知识">伍、算法和其他知识</h2><ol type="1"><li><p>随机的一个数组，求出其中连续段最多有几个数字，如[9，3，5，11，8，10，29，30]，连续的有四段，分别为{3}，{5}，{8，9，10，11}，{29，30}；要求时间复杂度O(n)、不能用排序，<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">题目戳这里</a></p></li><li><p>讲讲LRU和LFU、手撕LFU、怎么实现LFU最优</p></li><li><p>无序数组，找到最小的不存在于数组中的正整数</p></li><li><p>多个地铁站点，如何实现选择两站点的最优路线（时间、距离等因素），如果换乘时间也要考虑呢？</p></li><li><p>矩阵旋转</p></li><li><p>给一个表示扑克牌的整数数组（1-52），判断有无长度为5的顺子</p></li><li><p>二叉树层序遍历</p></li><li><p>下一个排列</p></li><li><p>mysql题: 查询成绩排名前5名的同学</p></li><li><p>leetcode113. 路径总和 II</p></li><li><p>简单的csv读取</p></li><li><p>两个版本号比大小，主/子版本号可能有前置0、中间用.分隔，版本号1小于版本号2时返回-1，等于时返回0，大于时返回1。如果一个版本号是另一个版本号的前缀，并且另一个版本号后跟子版本号都为0，那么认为这两个版本号相等，否则认为第二个版本号大于第一个版本号</p></li><li><p>一个二叉树，求树根到各个叶子结点路径上的k值之和，k值定义为路径上各节点值顺次连接而成的十进制数字：如1-&gt;2-&gt;4，1为根，4为叶，这条路经贡献的值为124</p></li><li><p>sql：《学生姓名得分表》中有四列，ID（学号/唯一key），name（可能重名），course（选课名，不同同学可能选择一样或不一样），score（0-100分，&lt;60分算不及格），每一行放置的是某一位同学某一门课程的得分 。求平均分不及格的学生姓名</p></li><li><p>假设给予一个数组，其size已知已知数组内放置的是排好序的自然数（从小到大）问数组内是否存在一个数，其重复的次数超过数组长度的一半期望时间复杂度O(logn) （例如100个数的一个数组，假如里面有一个数重复了超过50次，比如51次、55次、80次，那么返回True，否则返回False）</p></li><li><p>lc 43</p></li><li><p>模拟微信群随机红包，输入金额、人数，返回金额数组；注意最小单位分</p></li><li><p>lc 54 螺旋矩阵</p></li><li><p>怎么根据 0-5 随机函数得到 0-8 随机函数</p></li><li><p>找出一个数组中出现一次的数，其它都出现两次</p></li><li><p>数组中有两个出现过一次的数，怎么找</p></li><li><p>旋转数组求最小</p></li><li><p>写一个函数一秒内调用1000次返回true，超过1000次返回false，超过1s重新统计</p></li><li><p>Paxos算法原理</p></li><li><p>Service mesh了解吗</p></li><li><p>幂等</p></li><li><p>爬楼梯，一次最多爬2格；用数学公式证明写题的递推公式</p></li><li><p>给一个括号序列，求最长合法子串长度</p></li><li><p>LRU</p></li><li><p>json字符串怎么解析的</p></li><li><p>给一个固定长度的数组，用它实现一个先进先出的循环队列</p></li><li><p>求二叉搜索树第 k 大的数</p></li><li><p>二叉树Z遍历</p></li><li><p>google inject（依赖注入框架）及依赖注入的优点</p></li><li><p>递归写个斐波那契</p></li></ol><h2 id="陆发散性问题">陆、发散性问题</h2><ol type="1"><li>怎么学习技术的、有没有学过计算机相关的课，自己是如何学的</li><li>项目经历和实习经历、收获是什么、项目的架构和技术难点</li><li>项目中的难点、模块然后还问了一些依赖模块的底层实现</li><li>项目的数据量以及 QPS 能达到多少</li><li>对数据结构有什么理解</li><li>项目、实习的收获和不足</li><li>时间为15:30的时针与分针的夹角</li><li>设计操作系统的复制粘贴功能</li><li>个人优点和缺点</li><li>性格、优点缺点、大学生活、成绩等等这些</li><li>实习时长</li><li>来字节最想得到什么、想做什么</li><li>你希望你处于一个什么样的工作环境</li><li>学过什么课程</li><li>为了面试做了什么准备</li><li>为什么要做程序员</li><li>你觉得你聪明吗</li><li>对岗位的了解</li><li>对字节的了解</li><li>内心的源动力来源于什么</li><li>职业规划</li></ol><h2 id="柒反问环节">柒、反问环节</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大早上睡不着的时候翻&lt;a href=&quot;https://www.nowcoder.com/&quot;&gt;牛客&lt;/a&gt;搜字节三面，总结出来的各种问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这篇博客没有答案、只有问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案我估计还得查几天，再慢慢总结吧~&lt;/p&gt;
</summary>
      
    
    
    
    <category term="经验分享" scheme="https://doubleyue.life/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>通过hexo+github配置个人博客的过程</title>
    <link href="https://doubleyue.life/2022/05/13/%E9%80%9A%E8%BF%87hexo+github%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>https://doubleyue.life/2022/05/13/%E9%80%9A%E8%BF%87hexo+github%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2022-05-13T04:49:01.000Z</published>
    <updated>2022-05-14T05:13:28.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="壹购买域名并设置">壹、购买域名并设置</h3><ol type="1"><li><p>注册域名就可以通过个人独特的域名访问自己的博客啦~</p><p>当然也可以不注册，不注册域名的话也可以用github.io来访问，都一样的</p></li><li><p>现在挺多平台都可以注册域名，我选择了<a href="https://wanwang.aliyun.com/domain/searchresult/#/?keyword=&amp;suffix=com">阿里云</a>，自己找个自己喜欢的域名就可以啦~我自己定了<code>doubleyue.life</code></p></li><li><p>域名配置DNS解析，如下图所示：箭头指向的地方就用github的用户名<code>xxx.github.io</code>就行</p><figure><img src="image-20220513134905627.png" alt="image-20220513134905627"><figcaption aria-hidden="true">image-20220513134905627</figcaption></figure></li></ol><h3 id="贰安装git">贰、安装git</h3><ol type="1"><li>到<a href="https://git-scm.com/">官网</a>下载安装</li></ol><h3 id="叁创建github仓库">叁、创建GitHub仓库</h3><ol type="1"><li>在<a href="https://github.com/">github</a>创建个人博客的仓库，我的是<a href="https://github.com/TracyWang-0/doubleyue">doubleyue</a></li></ol><h3 id="肆在仓库创建pages页面并修改域名">肆、在仓库创建pages页面，并修改域名</h3><ol type="1"><li><p>在新创建的仓库的设置页面，不是个人中心的设置啊</p><figure><img src="image-20220513140338867.png" alt="image-20220513140338867"><figcaption aria-hidden="true">image-20220513140338867</figcaption></figure></li><li><p>选择pages，然后<code>choose a theme</code>，然后就等一会儿，反应会有点慢，就出现下面的页面了！</p><p>通过上面的链接就可以访问当前仓库，如果有购买域名的话，可以把<code>3</code>那里修改成自己的域名，然后保存一下，再等会儿，就可以通过自己的域名访问这个仓库啦~</p><figure><img src="image-20220513140629704.png" alt="image-20220513140629704"><figcaption aria-hidden="true">image-20220513140629704</figcaption></figure></li></ol><h3 id="伍关联仓库和本地主机">伍、关联仓库和本地主机</h3><ol type="1"><li><p>打开本地终端，把下面的复制到终端，修改下邮件地址</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"GitHub的邮件地址"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>打开目录<code>~/.ssh</code>，找到<code>id_rsa.pub</code>文件，用文本编辑器打开，全选复制</p></li><li><p>打开GitHub的个人设置页面，选择<code>SSH and GPG keys</code>，新建一个ssh key，名称随便，把刚才复制的文本粘贴进去，保存就好</p></li><li><p>测试是否成功链接。把下面的复制到终端，<strong>啥也不用改</strong>，回车后如果出现自己的GitHub名字就说明关联成功啦~</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="陆安装hexo">陆、安装hexo</h3><ol type="1"><li><p>安装node.js，到<a href="https://nodejs.org/en/download/">官网</a>下载安装</p></li><li><p>安装hexo</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo<span class="token comment"># 查看版本</span>hexo -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="柒初始化本地博客目录">柒、初始化本地博客目录</h3><ol type="1"><li><p>直接在终端输入下面的语句，<code>myblog</code>可以自己改个名字，运行完以后会生成这个文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init myblog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="捌创建一个博客并在本地测试">捌、创建一个博客并在本地测试</h3><ol type="1"><li><p>创建一个test博客，可以在<code>source/_post</code>下找到<code>test.md</code></p><pre class="line-numbers language-none"><code class="language-none">hexo new post "test"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>生成并本地测试，输入下面代码运行完以后</p><pre class="line-numbers language-none"><code class="language-none">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开浏览器，输入<code>localhost:4000</code>，就可以看到自己的博客了</p></li></ol><h3 id="玖部署到github仓库并打开域名查看">玖、部署到GitHub仓库并打开域名查看</h3><ol type="1"><li><p>部署到GitHub的过程会比较慢，所以我一般先本地测试正常以后，再部署。通过下面的语句就可以部署啦~</p><pre class="line-numbers language-none"><code class="language-none">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>打开自己的域名，比如我的<code>doubleyue.life</code>，就可以看到自己的博客啦~</p><p>不过部署真的很慢，要等好几分钟才能看到更新</p><p>后面如果更换主题需要配置的项目比较多，本地测试，然后直接部署就行~</p><p>之前没想到部署后这么久才能看到更新，所以一直以为自己哪里搞错了。。。</p></li></ol><h3 id="拾找个自己喜欢的主题并进行一系列的配置">拾、找个自己喜欢的主题并进行一系列的配置</h3><ol type="1"><li><p>在<a href="https://hexo.io/themes/">hexo的主题页</a>选择自己的喜欢的主题，进入相应的教程进行配置就好啦</p></li><li><p>我这里选择的是<a href="https://fi3ework.github.io/archer-demo/">archer</a>，跟着配置步骤一步步来就好啦~</p><p>这个主题现在还有人在进行维护，之前遇到了问题，咨询后很快就得到了回复，超棒！</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;壹购买域名并设置&quot;&gt;壹、购买域名并设置&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;注册域名就可以通过个人独特的域名访问自己的博客啦~&lt;/p&gt;
&lt;p&gt;当然也可以不注册，不注册域名的话也可以用github.io来访问，都一样的&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p</summary>
      
    
    
    
    <category term="经验分享" scheme="https://doubleyue.life/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>OSI七层模型和TCP/IP五层模型</title>
    <link href="https://doubleyue.life/2022/05/12/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8CTCP-IP%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>https://doubleyue.life/2022/05/12/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8CTCP-IP%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-05-12T02:13:56.000Z</published>
    <updated>2022-05-13T04:48:31.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一osi七层模型">一、OSI七层模型</h2><p>从下到上依次为：① 物理层、② 数据链路层、③ 传输层、④ 网络层、 ⑤ 应用层、⑥ 会话层、 ⑦ 表示层</p><h2 id="二tcpip五层模型">二、TCP/IP五层模型</h2><p>从OSI七层模型发展而来，从下到上依次为：① 物理层、② 数据链路层、③ 传输层、④ 网络层、 ⑤ 应用层</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一osi七层模型&quot;&gt;一、OSI七层模型&lt;/h2&gt;
&lt;p&gt;从下到上依次为：① 物理层、② 数据链路层、③ 传输层、④ 网络层、 ⑤ 应用层、⑥ 会话层、 ⑦ 表示层&lt;/p&gt;
&lt;h2 id=&quot;二tcpip五层模型&quot;&gt;二、TCP/IP五层模型&lt;/h2&gt;
&lt;p&gt;从OSI七</summary>
      
    
    
    
    <category term="知识积累" scheme="https://doubleyue.life/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="计算机网络" scheme="https://doubleyue.life/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的六大原则</title>
    <link href="https://doubleyue.life/2022/05/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>https://doubleyue.life/2022/05/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</id>
    <published>2022-05-11T06:55:24.000Z</published>
    <updated>2022-05-13T04:47:05.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一单一职责原则">一、单一职责原则</h2><p>每个模块/类都应该对软件提供的功能的一部分负责，而这个责任应该完全由类来封装。</p><h2 id="二开闭原则">二、开闭原则</h2><p>软件中的对象(类、模块、函数等)对扩展是开放的，对修改是封闭的。 当然，这只是理想化的愿景，在实际开发中，修改原有代码、扩展代码往往是同时存在的。 已存在的实现类对于修改是封闭的，新的实现类可以通过覆写父类的接口应对变化。</p><h2 id="三里氏替换原则">三、里氏替换原则</h2><p>所有使用基类的地方必须能透明地使用其子类的对象</p><h2 id="四依赖倒转原则">四、依赖倒转原则</h2><p>是指一种特定的解耦（传统的依赖关系建立在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</p><ol type="1"><li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</li><li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li></ol><h2 id="五接口隔离原则">五、接口隔离原则</h2><p>类不应该依赖它不需要的接口。</p><h2 id="六迪米特法则">六、迪米特法则</h2><p>也称最少知识法则</p><ol type="1"><li>每个对象应该对其他对象的信息知道的尽可能的少</li><li>每个对象应该仅直接和其朋友通信；不和陌生人通信</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一单一职责原则&quot;&gt;一、单一职责原则&lt;/h2&gt;
&lt;p&gt;每个模块/类都应该对软件提供的功能的一部分负责，而这个责任应该完全由类来封装。&lt;/p&gt;
&lt;h2 id=&quot;二开闭原则&quot;&gt;二、开闭原则&lt;/h2&gt;
&lt;p&gt;软件中的对象(类、模块、函数等)对扩展是开放的，对修改是封闭的。</summary>
      
    
    
    
    <category term="知识积累" scheme="https://doubleyue.life/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="设计模式" scheme="https://doubleyue.life/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="https://doubleyue.life/2022/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://doubleyue.life/2022/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-05-11T06:25:10.000Z</published>
    <updated>2022-05-13T04:47:17.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一是什么">一、是什么</h3><p>定义：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><p>因此有几个特征：</p><ol type="1"><li>构造方法不能公开，只能是private</li><li>这个实例是当前类的实例，也就是当前类的类成员变量，用static修饰的类静态变量</li><li>需要提供一个静态方法，向外界提供当前类的实例</li></ol><p>应用场景：</p><ol type="1"><li>序列号生成器</li><li>web页面的计数器</li><li>如果创建一个对象需要消耗很多资源的时候，可以用单例模式来减少资源消耗</li></ol><h3 id="二分类">二、分类</h3><p>根据实例化的时机不同，可以分为饿汉式和懒汉式。</p><ol type="1"><li><p>饿汉模式：在类加载的时候，立刻实例化。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>懒汉模式：</p><ol type="1"><li>基础：在第一次使用的时候进行实例化。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2" type="1"><li>双重检查锁：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例化具体步骤：</p><p>① 分配内存；② 初始化对象；③ 指向刚分配的地址。</p><p>但是可能发生重排序：</p><p>假设 A 线程执行了①和③，B 线程过来判断为null，B就直接返回尚未实例化的instance了。使用volatile可以避免重排序。</p></li></ol><h3 id="三存在的问题">三、存在的问题：</h3><ol type="1"><li>多个实例的情况<ol type="1"><li>在分布式系统中，多个JVM虚拟机，各个虚拟机都有一个实例。</li><li>同一个JVM虚拟机的多个类加载器同时加载这个类，也会产生多个实例。</li></ol></li><li>只有一个实例，类中的变量可能会因为被修改而导致出错。因此最好以无状态的工具类提供。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一是什么&quot;&gt;一、是什么&lt;/h3&gt;
&lt;p&gt;定义：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。&lt;/p&gt;
&lt;p&gt;因此有几个特征：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;构造方法不能公开，只能是private&lt;/li&gt;
&lt;li&gt;这个实例是当前类的</summary>
      
    
    
    
    <category term="知识积累" scheme="https://doubleyue.life/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="设计模式" scheme="https://doubleyue.life/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="https://doubleyue.life/2022/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://doubleyue.life/2022/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-05-11T05:02:43.000Z</published>
    <updated>2022-05-13T04:47:29.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一简单工厂模式simple-factory-pattern">一、简单工厂模式Simple Factory Pattern</h3><p>又称静态工厂方法Static Factory Method，属于<strong>创建型模式</strong>。</p><p>根据参数的不同返回不同类的实例。</p><p>简单工厂模式专门创建一个类来创建其他类的实例，被创建的实例通常具有共同的父类。类图如下：</p><p><img src="image-20220511132031921.png" alt="image-20220511132031921" style="zoom:50%;"></p><p>优点：将对象的创建和使用分离，把创建产品的过程交给专门的工厂类负责，客户端不用管具体是如何实现的</p><p>缺点：不够灵活，新增一个产品就需要修改工厂类，在工厂中加入必要的业务逻辑，违反了<strong>开闭原则</strong>。</p><h3 id="二工厂模式">二、工厂模式</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。也就是说：</p><p>把核心工厂变成一个抽象接口，为不同的产品创建不同的子工厂，这样子产品的实例化将在子工厂中完成，如果增加新的产品，则创建新的子工厂即可，不需要修改原来的工厂类。类图如下：</p><figure><img src="image-20220511133928629.png" alt="image-20220511133928629"><figcaption aria-hidden="true">image-20220511133928629</figcaption></figure><h3 id="三抽象工厂模式">三、抽象工厂模式</h3><p>是工厂模式的扩展，使得每个子工厂可以创建多个产品，如果只有一个产品体系的话会退化成工厂模式，类图如下：</p><figure><img src="image-20220511142208829.png" alt="image-20220511142208829"><figcaption aria-hidden="true">image-20220511142208829</figcaption></figure><p>缺点：如果需要增加产品体系的话，仍旧需要修改抽象工厂和具体工厂的代码，违反<strong>开闭原则</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一简单工厂模式simple-factory-pattern&quot;&gt;一、简单工厂模式Simple Factory Pattern&lt;/h3&gt;
&lt;p&gt;又称静态工厂方法Static Factory Method，属于&lt;strong&gt;创建型模式&lt;/strong&gt;。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="知识积累" scheme="https://doubleyue.life/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="设计模式" scheme="https://doubleyue.life/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>2022暑期实习华为面试经验分享</title>
    <link href="https://doubleyue.life/2022/05/10/2022%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <id>https://doubleyue.life/2022/05/10/2022%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</id>
    <published>2022-05-10T15:25:30.000Z</published>
    <updated>2022-05-13T04:46:47.367Z</updated>
    
    <content type="html"><![CDATA[<p>华为池子，深不可测~ 不过流程进展很快，而且很快会给结果，整体感觉很棒。</p><ol type="1"><li>投递简历：</li></ol><p>在有个实习群里加到以为hr，说有hc，于是投递了通用软件开发工程师的岗位，可以投两个意向。（但是第二个意向其实是不起作用的。</p><ol start="2" type="1"><li>笔试：</li></ol><p>第二周的周二收到周三晚上笔试的邮件，共3道题（分值100,200,300），达到100分就有面试机会。比较麻烦的点在于输入输出，需要从字符串解析出需要读取的数字，输出也是需要把数组转成串输出。</p><ol start="3" type="1"><li>综合测评：</li></ol><p>一周内收到邮件参加综合测评和面试，问了hr说是性格测试，约35min可以完成。有同学表示这个测试不过的话，可以再次参加一次。</p><ol start="4" type="1"><li>技术面：</li></ol><p>同综合测评一起发来的邮件，面试邀约第三周周二下午，可能因为前一个人的时间比较长，面试官上线的时间比预期晚了大约半个小时，面试全程约70min</p><p>​ • 首先介绍下项目，面试官问了点细节，包括自己实现部分的代码量，不难</p><p>​ • 两道编程题，共享屏幕编程：</p><p>​ ◦ 给满二叉树的前序遍历结果，输出后序遍历；一开始以为是完全二叉树，卡住了。。后来面试官提醒了下是满二叉树，然后就很流畅的写完啦</p><p>​ ◦ 上次机试第一题，上次没做出来，然后面试官就让我试试，因为一直不想做这个，所以也磕磕绊绊的，到最后也没完全做出来</p><p>​ • 问了几个八股问题：内核态是什么、线程同时读写问题、还有一些不太记得了，准备下八股问题！</p><p>差不多20min后收到面试通过的短信，很快很赞</p><ol start="5" type="1"><li><p>主管面：</p><p>两天后约了主管面，面试全程约35min</p></li></ol><p>​ • 问了些简历上的问题，多是关于大学的事情，以及职业规划方面的问题，因为准备不够，所以有些问题回答的不是特别好。需要认真准备准备！</p><p>​ • 反问：</p><p>​ ◦ 对互联网裁员的看法</p><p>​ ◦ 实习生的加班情况</p><p>​ ◦ 主要工作内容</p><p>也是差不多20分钟后收到了面试通过的短信，效率很快，超级赞。</p><ol start="6" type="1"><li>面试反馈：</li></ol><p>次日收到面试反馈邮件，对面试评价，五颗星好评</p><ol start="7" type="1"><li>查看官网应聘状态：</li></ol><p>​ • 在官网-个人中心-申请进展页面，按F12</p><p>​ • 选择 network - XHR</p><p>​ • F5刷新页面</p><p>​ • 点一下queryMyJobInterviewPortal...</p><p>​ • 关键属性：</p><p>​ ◦ Index在第一个，说明还在池子等着提交审批</p><p>​ ◦ resume_type提前，说明审批通过，快发意向了，但是牛客上也有说resume_type提前仍旧无消息的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;华为池子，深不可测~ 不过流程进展很快，而且很快会给结果，整体感觉很棒。&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;投递简历：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在有个实习群里加到以为hr，说有hc，于是投递了通用软件开发工程师的岗位，可以投两个意向。（但是第二个意向其实是不起</summary>
      
    
    
    
    <category term="经验分享" scheme="https://doubleyue.life/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>C++八股</title>
    <link href="https://doubleyue.life/2022/05/10/Cplusplus%E5%85%AB%E8%82%A1/"/>
    <id>https://doubleyue.life/2022/05/10/Cplusplus%E5%85%AB%E8%82%A1/</id>
    <published>2022-05-10T14:59:53.000Z</published>
    <updated>2022-05-13T04:48:08.154Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一c和c的区别">一、C++和C的区别</h3><ol type="1"><li>面向过程和面向对象的区别</li><li>关键字不一样</li></ol><h3 id="二几个关键字">二、几个关键字</h3><ol type="1"><li>volatile</li><li>final</li><li>const</li></ol><h3 id="三三个特性">三、三个特性</h3><ol type="1"><li>封装</li><li>继承</li><li>多态</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一c和c的区别&quot;&gt;一、C++和C的区别&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;面向过程和面向对象的区别&lt;/li&gt;
&lt;li&gt;关键字不一样&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;二几个关键字&quot;&gt;二、几个关键字&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;vo</summary>
      
    
    
    
    <category term="知识积累" scheme="https://doubleyue.life/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="C++" scheme="https://doubleyue.life/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="https://doubleyue.life/2022/05/10/MySQL%E7%B4%A2%E5%BC%95/"/>
    <id>https://doubleyue.life/2022/05/10/MySQL%E7%B4%A2%E5%BC%95/</id>
    <published>2022-05-10T14:55:13.000Z</published>
    <updated>2022-05-13T04:48:18.458Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一什么是index">一、什么是index</h3><ol type="1"><li>帮助MySQL提高查询效率的<strong>数据结构</strong></li><li>优点：大大加快数据查询速度</li><li>缺点：①维护索引需要耗费数据库资源；②占用磁盘空间；③对表的数据进行增删改的时候需要维护索引，速度会受到影响。</li></ol><h3 id="二索引分类">二、索引分类</h3><ol type="1"><li>innoDB<ol type="1"><li>主键索引：设置为主键的时候，innodb为<strong>聚簇索引</strong>，不允许有空值</li><li>单值索引/单列索引/普通索引：一个索引只包含单个列，一个表可以有多个单列索引</li><li>唯一索引：索引列的值必须唯一，允许有空值，但是只能有一个null</li><li>复合索引：一个索引包含多个列</li></ol></li><li>myISAM（不需要背）<ol start="5" type="1"><li>full text全文索引：在定义索引的列上支持值的全文查找，允许空值、重复值，只能在文本类型就行创建</li></ol></li></ol><h3 id="三索引的基本操作">三、索引的基本操作</h3><ol type="1"><li><p>创建主键索引，在建表的时候自动创建<code>show index from table</code></p></li><li><p>创建单值索引：</p><ol type="1"><li>建表的时候创建：添加<code>key(name)</code>，无法指定索引名字，默认列名为索引名</li><li>建表之后创建：<code>create index [name] on table(name)</code></li></ol></li><li><p>创建唯一索引：</p><ol type="1"><li>建表的时候创建：添加<code>unique(name)</code>，无法指定索引名字，默认列名为索引名</li><li>建表之后创建：<code>create unique index [name] on table(name)</code></li></ol></li><li><p>复合索引</p><ol type="1"><li><p>建表的时候创建：添加<code>key(name, age)</code>，无法指定索引名字，默认列名为索引名</p></li><li><p>建表之后创建：<code>create unique index [name] on table(name,age)</code></p></li><li><p>Key_name为同一个，都是第一个name</p></li><li><p>利用复合索引需要符合<strong>最左前缀原则</strong>；MySQL会<strong>动态调整字段顺序</strong>以便利用索引</p><p><img src="image-20220505233324023.png" alt="image-20220505233324023" style="zoom:80%;"></p></li></ol></li></ol><h3 id="四innodb引擎底层数据结构">四、innodb引擎底层数据结构</h3><p>是B+树，是B树的一种优化</p><ol type="1"><li>根据主键索引进行排序，链接起来</li><li>一页16kb，可以存储多个结点</li><li>页目录也是16kb：存储每一页第一个结点的<strong>索引值</strong>和<strong>指针</strong>（指向每一页）</li><li>一般3层就是很庞大的数据量了，约10亿数据量</li><li>根节点常驻内存，一般2<sub>4层，最多1</sub>3次磁盘IO</li></ol><h3 id="五b-tree和btree的区别">五、B-tree和B+tree的区别：</h3><ol type="1"><li>b-tree的每个节点都需要存储完整的数据</li><li>b+tree只有叶子节点存储数据，可以降低树的高度</li></ol><h3 id="六聚簇索引和非聚簇索引">六、聚簇索引和非聚簇索引</h3><ol type="1"><li><p>聚簇索引：将数据存储与索引放到了一起，索引结构的叶子节点保存了行数据。比如主键索引等。</p><ol type="1"><li>默认是主键，如果没有主键，则会选择一个唯一且非空的索引代替；</li><li>如果这个索引也没有，innodb会隐式定义一个主键来作为聚簇索引；</li><li>如果已设置了主键为聚簇索引而想要单独设置聚簇索引，必须先删除主键--&gt;添加聚簇索引--&gt;恢复主键。</li></ol></li><li><p>非聚簇索引：将数据与索引分开存储，索引结构的叶子结点指向了数据对应的位置。比如单列索引等</p></li><li><p>特点：①在innodb中，一个表中只能有一个聚簇索引，在聚簇索引上创建的索引称之为辅助索引；②非聚簇索引都是辅助索引，比如单列索引、唯一索引、复合索引。③<strong>辅助索引</strong>的叶子节点存储的不是行的物理位置，而是主键值。④辅助索引访问数据总是需要<strong>二次查找</strong>。</p><p><img src="image-20220506001614319.png" alt="image-20220506001614319" style="zoom:75%;"></p></li><li><p>面试题：为什么辅助索引插入的主键值而不是物理位置？因为增删改的时候需要修改地址，如果非聚簇索引存储的地址，会导致在增删改的时候额外修改索引。</p></li></ol><h3 id="七myisam的索引非聚簇索引">七、myISAM的索引：非聚簇索引</h3><p><img src="image-20220506002554510.png" alt="image-20220506002554510" style="zoom:75%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一什么是index&quot;&gt;一、什么是index&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;帮助MySQL提高查询效率的&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;优点：大大加快数据查询速度&lt;/li&gt;
&lt;li&gt;缺点：①维护索引需要耗费数据库资源；②</summary>
      
    
    
    
    <category term="知识积累" scheme="https://doubleyue.life/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="数据库" scheme="https://doubleyue.life/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
